{% extends "base.html" %}

{% block progress_bar %}
<div class="progress-display">
    <span class="progress-label">Progress:</span>
    <span class="progress-percentage">{{ progress }}%</span>
</div>
{% endblock %}

{% block extra_css %}
<link href="https://fonts.googleapis.com/css2?family=Bangers&family=Fredoka+One&family=Nunito:wght@800;900&display=swap" rel="stylesheet">
<style>
    :root {
        --deep-burgundy: #2a0a0a;
        --evergreen: #013220;
        --evergreen-light: #025235;
        --gold: #d4af37;
        --gold-bright: #ffdf00;
        --white: #ffffff;
        --glass: rgba(255, 255, 255, 0.1);
        --glass-border: rgba(255, 255, 255, 0.2);
    }

    body {
        margin: 0;
        padding: 0;
        background: radial-gradient(circle at center, #3d0000 0%, var(--deep-burgundy) 100%);
        min-height: 100vh;
        overflow-y: auto !important;
        overflow-x: hidden !important;
        font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
    }

    /* Playful bold cartoon font for headings/titles only */
    h1, h2, h3, .reindeer-module-header h1, .success-message h2, .game-over h3 {
        font-family: 'Bangers', 'Fredoka One', 'Nunito', 'Comic Sans MS', 'Impact', 'Arial Black', sans-serif;
        font-weight: 900;
        letter-spacing: 0.05em;
        text-transform: uppercase;
    }

    /* Fixed Background Layer for Vignette */
    .vignette-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none;
        background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.6) 100%);
    }

    .reindeer-module-container {
        padding: 2rem;
        max-width: 1000px;
        margin: 0 auto;
        color: #ffffff;
        position: relative;
        z-index: 2;
    }

    .reindeer-module-header {
        text-align: center;
        margin-bottom: 2rem;
    }

    .reindeer-module-header h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
    }

    .reindeer-module-header p {
        color: #888;
        font-size: 1.1rem;
    }

    .game-status {
        text-align: center;
        margin-bottom: 2rem;
        padding: 1rem;
        background: #0f0f0f;
        border: 2px solid #333;
        border-radius: 8px;
    }

    .game-status.completed {
        border-color: #4CAF50;
        background: rgba(76, 175, 80, 0.1);
    }

    .instructions {
        background: #0f0f0f;
        border: 2px solid #228B22;
        border-radius: 8px;
        padding: 1.5rem;
        margin-bottom: 2rem;
        text-align: center;
    }

    .instructions h3 {
        color: #228B22;
        margin-bottom: 1rem;
        font-size: 1.2rem;
    }

    .instructions p {
        color: #ccc;
        line-height: 1.6;
    }

    .game-area {
        background: #0a0a0a;
        border: 3px solid #333;
        border-radius: 12px;
        height: 400px;
        width: 100%;
        position: relative !important;
        overflow: hidden !important;
        margin-bottom: 2rem;
        min-height: 300px;
        box-sizing: border-box;
    }

    @media (max-width: 768px) {
        .game-area {
            height: 300px;
            min-height: 250px;
        }

        .reindeer {
            font-size: 3rem;
        }

        .obstacle {
            width: 30px;
            height: 40px;
        }

        .obstacle::before {
            font-size: 2rem;
        }
    }

    @media (max-width: 480px) {
        .game-area {
            height: 250px;
            min-height: 200px;
        }

        .reindeer {
            font-size: 2.5rem;
        }

        .obstacle {
            width: 25px;
            height: 35px;
        }

        .obstacle::before {
            font-size: 1.5rem;
        }
    }

    .ground {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 80px;
        background: linear-gradient(to top, #2a2a2a, #1a1a1a);
        border-top: 2px solid #444;
    }

    .reindeer {
        position: absolute;
        bottom: 80px;
        left: 15%;
        font-size: 4rem;
        transition: transform 0.1s ease;
        z-index: 10;
        transform: scaleX(-1);
    }

    .reindeer.jumping {
        transform: scaleX(-1) translateY(-140px);
        transition: transform 0.35s ease;
    }

    .obstacle {
        position: absolute !important;
        bottom: 80px !important;
        left: 100% !important;
        width: 40px !important;
        height: 40px !important;
        min-width: 40px !important;
        min-height: 40px !important;
        background: #ff4444 !important;
        border: 2px solid #cc0000 !important;
        border-radius: 4px !important;
        display: block !important;
        z-index: 5 !important;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5) !important;
        visibility: visible !important;
        opacity: 1 !important;
        pointer-events: auto !important;
    }

    .obstacle::before {
        display: none !important;
    }

    .game-controls {
        text-align: center;
        margin-bottom: 2rem;
    }

    .jump-button {
        padding: 1rem 3rem;
        background: #228B22;
        color: #ffffff;
        border: none;
        border-radius: 8px;
        font-size: 1.2rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 600;
    }

    .jump-button:hover {
        background: #2d8f2d;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(34, 139, 34, 0.3);
    }

    .jump-button:active {
        transform: translateY(0);
    }

    .jump-button:disabled {
        background: #333;
        cursor: not-allowed;
        transform: none;
    }

    .progress-indicator {
        text-align: center;
        margin-bottom: 1rem;
        font-size: 1.1rem;
        color: #888;
    }

    .progress-indicator span {
        color: #228B22;
        font-weight: 600;
    }

    .module-actions {
        text-align: center;
        margin-top: 2rem;
    }

    .complete-button {
        display: inline-block;
        padding: 1rem 3rem;
        background: #4CAF50;
        color: #ffffff;
        border: none;
        border-radius: 8px;
        font-size: 1.1rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        cursor: pointer;
        transition: all 0.3s ease;
        text-decoration: none;
    }

    .complete-button:hover {
        background: #45a049;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(76, 175, 80, 0.3);
    }

    .complete-button:disabled {
        background: #333;
        cursor: not-allowed;
        transform: none;
    }

    .back-button {
        display: inline-block;
        padding: 0.8rem 2rem;
        color: #ffffff;
        border: 2px solid #ffffff;
        text-decoration: none;
        font-size: 1rem;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        transition: all 0.3s ease;
        margin-left: 1rem;
    }

    .back-button:hover {
        background: #ffffff;
        color: #1a1a1a;
    }

    .success-message {
        text-align: center;
        padding: 2rem;
        background: rgba(76, 175, 80, 0.1);
        border: 2px solid #4CAF50;
        border-radius: 12px;
        margin-bottom: 2rem;
    }

    .success-message h2 {
        color: #4CAF50;
        font-size: 2rem;
        margin-bottom: 1rem;
    }

    .game-over {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        padding: 2rem;
        border-radius: 12px;
        border: 2px solid #ff4444;
        text-align: center;
        z-index: 100;
        display: none;
    }

    .game-over.show {
        display: block;
    }

    .game-over h3 {
        color: #ff4444;
        font-size: 1.5rem;
        margin-bottom: 1rem;
    }

    .restart-button {
        padding: 0.8rem 2rem;
        background: #228B22;
        color: #ffffff;
        border: none;
        border-radius: 8px;
        font-size: 1rem;
        cursor: pointer;
        margin-top: 1rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="vignette-overlay"></div>
<div class="reindeer-module-container">
    <div class="reindeer-module-header">
        <h1>ü¶å Reindeer Navigation Challenge</h1>
        <p>Guide the reindeer safely through obstacles!</p>
    </div>

    {% if is_completed %}
    <div class="success-message">
        <h2>‚úì Module Completed!</h2>
        <p>You've successfully navigated through all obstacles. Great flying!</p>
    </div>
    {% else %}
    <div class="instructions">
        <h3>How to Play</h3>
        <p>Press <strong>SPACEBAR</strong> or click the <strong>JUMP</strong> button to make the reindeer jump over obstacles.<br>
        Avoid 5 obstacles to complete the challenge!</p>
    </div>

    <div class="game-status" id="gameStatus">
        <div>Navigate through obstacles</div>
        <div class="progress-indicator">Obstacles Avoided: <span id="obstaclesAvoided">0</span>/5</div>
    </div>

    <div class="game-area" id="gameArea">
        <div class="ground"></div>
        <div class="reindeer" id="reindeer">ü¶å</div>
        <div class="game-over" id="gameOver">
            <h3>üí• Collision!</h3>
            <p>Press restart to try again</p>
            <button class="restart-button" onclick="restartGame()">Restart</button>
        </div>
    </div>

    <div class="game-controls">
        <button class="jump-button" id="jumpButton" onclick="jump()">JUMP (SPACE)</button>
    </div>

    <div class="module-actions">
        <form method="POST" action="{{ url_for('complete_reindeer') }}" id="completeForm" style="display: none;">
            <button type="submit" class="complete-button" id="completeButton">Complete Module</button>
        </form>
        <a href="{{ url_for('map') }}" class="back-button">Back to Control Room</a>
    </div>
    {% endif %}
</div>
{% endblock %}

    {% block extra_js %}
<!-- Background Audio -->
<audio id="bgAudio" loop preload="auto" style="display: none;">
    <source src="{{ url_for('static', filename='assets/audio/bg_song2.mp3') }}" type="audio/mpeg">
</audio>

<script>
    // Background audio initialization
    (function() {
        function initBackgroundAudio() {
            const audio = document.getElementById('bgAudio');
            if (!audio) return;
            
            audio.volume = 0.5;
            
            function playAudio() {
                if (!audio.paused) return;
                
                const playPromise = audio.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.warn('Autoplay blocked:', error);
                    });
                }
            }
            
            audio.addEventListener('canplay', playAudio);
            audio.addEventListener('canplaythrough', playAudio);
            
            const events = ['click', 'touchstart', 'mousedown', 'keydown'];
            events.forEach(eventType => {
                document.addEventListener(eventType, playAudio, { once: true });
            });
            
            setTimeout(playAudio, 1000);
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initBackgroundAudio);
        } else {
            initBackgroundAudio();
        }
    })();
</script>

<script>
    {% if not is_completed %}
    (function() {
        let gameRunning = false;
        let isJumping = false;
        let obstaclesAvoided = 0;
        let obstacles = [];
        let gameSpeed = 6;
        let obstacleInterval;
        let animationFrame;
        const targetObstacles = 5;

        const reindeer = document.getElementById('reindeer');
        const gameArea = document.getElementById('gameArea');
        const jumpButton = document.getElementById('jumpButton');
        const gameOver = document.getElementById('gameOver');
        let obstaclesAvoidedEl = document.getElementById('obstaclesAvoided');
        
        // Verify game area exists
        if (!gameArea) {
            console.error('‚ùå Game area element not found!');
        } else {
            console.log('‚úÖ Game area found. Width:', gameArea.offsetWidth, 'Height:', gameArea.offsetHeight);
        }
        
        if (!reindeer) {
            console.error('‚ùå Reindeer element not found!');
        }

        // Get responsive reindeer position - more consistent across screen sizes
        function getReindeerPosition() {
            const gameAreaWidth = gameArea.offsetWidth || 800;
            // Use 15% of game area width, but ensure minimum 60px for visibility
            return Math.max(60, Math.min(200, gameAreaWidth * 0.15));
        }

        // Reindeer position constants (will be calculated dynamically)
        function getReindeerLeft() {
            // Try to get actual position from DOM element first
            if (reindeer) {
                const reindeerRect = reindeer.getBoundingClientRect();
                const gameAreaRect = gameArea.getBoundingClientRect();
                const actualLeft = reindeerRect.left - gameAreaRect.left;
                if (actualLeft > 0) {
                    return actualLeft;
                }
            }
            // Fallback to calculated position
            return getReindeerPosition();
        }

        function getReindeerWidth() {
            return 50; // Fixed width for consistent collision detection
        }

        function getReindeerHeight() {
            return 50; // Fixed height for consistent collision detection
        }

        const REINDEER_BOTTOM = 80;
        
        function getReindeerGroundY() {
            const gameAreaHeight = gameArea.offsetHeight || 400;
            return gameAreaHeight - REINDEER_BOTTOM - getReindeerHeight();
        }

        // Obstacle constants (simple square boxes)
        function getObstacleWidth() {
            return 40; // Fixed size - small red square
        }

        function getObstacleHeight() {
            return 40; // Fixed size - small red square
        }

        const OBSTACLE_BOTTOM = 80;

        // Update reindeer position on resize
        function updateReindeerPosition() {
            const reindeerLeft = getReindeerLeft();
            reindeer.style.left = reindeerLeft + 'px';
        }

        // Initial position setup
        updateReindeerPosition();
        
        // Update position on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                updateReindeerPosition();
            }, 100);
        });

        function jump() {
            if (!gameRunning || isJumping) return;
            
            isJumping = true;
            reindeer.classList.add('jumping');
            
            // Reset jump after animation completes
            // Jump animation is 400ms, so keep isJumping true for that duration
            setTimeout(() => {
                reindeer.classList.remove('jumping');
                // Keep isJumping true a bit longer to ensure collision doesn't happen during landing
                setTimeout(() => {
                    isJumping = false;
                }, 100);
            }, 400);
        }

        // Track last obstacle position to ensure gaps
        let lastObstaclePosition = 0;
        const MIN_OBSTACLE_GAP = 300; // Minimum gap between obstacles in pixels

        function createObstacle() {
            if (!gameRunning) {
                console.warn('Cannot create obstacle: game not running');
                return;
            }

            if (!gameArea) {
                console.error('Game area not found!');
                return;
            }

            const gameAreaWidth = gameArea.offsetWidth || 800;
            
            // Check if we need to wait for gap - ensure obstacles don't spawn too close
            if (obstacles.length > 0) {
                const currentRightmost = Math.max(...obstacles.map(obs => {
                    const left = parseFloat(obs.style.left) || gameAreaWidth;
                    return left + (parseFloat(obs.dataset.width) || 40);
                }));
                
                // Ensure minimum gap between obstacles
                if (currentRightmost > gameAreaWidth - MIN_OBSTACLE_GAP) {
                    return; // Wait for more gap
                }
            }

            const obstacle = document.createElement('div');
            obstacle.className = 'obstacle';
            const obstacleWidth = getObstacleWidth();
            const obstacleHeight = getObstacleHeight();
            
            // Set all styles explicitly - simple red square box
            obstacle.style.cssText = `
                position: absolute !important;
                bottom: ${OBSTACLE_BOTTOM}px !important;
                left: ${gameAreaWidth}px !important;
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                min-height: 40px !important;
                background: #ff4444 !important;
                border: 2px solid #cc0000 !important;
                border-radius: 4px !important;
                display: block !important;
                z-index: 5 !important;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5) !important;
                visibility: visible !important;
                opacity: 1 !important;
                pointer-events: auto !important;
            `;
            
            // No content - just a red square box
            obstacle.innerHTML = '';
            
            obstacle.dataset.counted = 'false';
            obstacle.dataset.width = obstacleWidth;
            obstacle.dataset.height = obstacleHeight;
            obstacle.dataset.created = Date.now();
            
            // Append to game area
            gameArea.appendChild(obstacle);
            obstacles.push(obstacle);
            
            // Force a reflow to ensure the obstacle is rendered
            obstacle.offsetHeight;
            
            // Verify obstacle is visible
            const rect = obstacle.getBoundingClientRect();
            if (rect.width === 0 || rect.height === 0) {
                console.warn('‚ö†Ô∏è Obstacle may not be visible! Rect:', rect.width, 'x', rect.height);
            }
            
            console.log('‚úÖ Obstacle created! Total obstacles:', obstacles.length, 'Position:', obstacle.style.left);
        }

        function checkCollision(obstacleLeft, obstacleRight, obstacleTop, obstacleBottom) {
            // Reindeer position boundaries (responsive)
            const reindeerLeft = getReindeerLeft();
            const reindeerWidth = getReindeerWidth();
            const reindeerRight = reindeerLeft + reindeerWidth;
            const gameAreaHeight = gameArea.offsetHeight || 400;
            const reindeerBottom = gameAreaHeight - REINDEER_BOTTOM;
            const reindeerHeight = getReindeerHeight();
            const reindeerTop = reindeerBottom - reindeerHeight;
            
            // Check horizontal overlap - simplified and more reliable
            const hasHorizontalOverlap = obstacleRight >= reindeerLeft && obstacleLeft <= reindeerRight;
            
            // Check vertical overlap (reindeer must be on ground, not jumping)
            const hasVerticalOverlap = !isJumping && obstacleBottom >= reindeerTop && obstacleTop <= reindeerBottom;
            
            // Collision occurs when both horizontal AND vertical overlap exist
            if (hasHorizontalOverlap && hasVerticalOverlap) {
                // Calculate overlap amount for more precise detection
                const horizontalOverlap = Math.min(obstacleRight, reindeerRight) - Math.max(obstacleLeft, reindeerLeft);
                const verticalOverlap = Math.min(obstacleBottom, reindeerBottom) - Math.max(obstacleTop, reindeerTop);
                
                // Require meaningful overlap (at least 5px) for collision - reduced threshold for better detection
                if (horizontalOverlap > 5 && verticalOverlap > 5) {
                    return true; // Collision!
                }
            }
            
            return false; // No collision
        }

        function updateObstacles() {
            if (!gameRunning) return;

            const gameAreaWidth = gameArea.offsetWidth || 800;
            const obstaclesToRemove = [];
            const reindeerLeft = getReindeerLeft();
            const reindeerRight = reindeerLeft + getReindeerWidth();

            obstacles.forEach((obstacle, index) => {
                // Get current position - use getBoundingClientRect for more accurate position
                let currentLeft = parseFloat(obstacle.style.left);
                if (isNaN(currentLeft)) {
                    const rect = obstacle.getBoundingClientRect();
                    const gameAreaRect = gameArea.getBoundingClientRect();
                    currentLeft = rect.left - gameAreaRect.left;
                }
                
                // Get obstacle dimensions (may vary on different screen sizes)
                const obstacleWidth = parseFloat(obstacle.dataset.width) || getObstacleWidth();
                const obstacleHeight = parseFloat(obstacle.dataset.height) || getObstacleHeight();
                const gameAreaHeight = gameArea.offsetHeight || 400;
                
                // Move obstacle left
                currentLeft -= gameSpeed;
                obstacle.style.left = currentLeft + 'px';

                // Calculate obstacle edges (horizontal)
                const obstacleLeft = currentLeft;
                const obstacleRight = currentLeft + obstacleWidth;
                
                // Calculate obstacle edges (vertical)
                const obstacleBottom = gameAreaHeight - OBSTACLE_BOTTOM;
                const obstacleTop = obstacleBottom - obstacleHeight;
                
                // Check if already counted
                const isCounted = obstacle.dataset.counted === 'true';

                // COUNTING LOGIC - Simplified and reliable
                // Count when obstacle's right edge passes reindeer's left edge
                if (!isCounted) {
                    // Count if obstacle is past reindeer (with small buffer to avoid counting during collision check)
                    // Check multiple conditions to ensure we catch all obstacles
                    const buffer = 15; // Small buffer to ensure obstacle has passed
                    const hasPassed = obstacleRight < reindeerLeft - buffer;
                    
                    // Also check if obstacle is clearly on the left side of reindeer
                    const isOnLeftSide = obstacleRight < reindeerLeft;
                    
                    if (hasPassed || (isOnLeftSide && obstacleRight < reindeerLeft - 5)) {
                        obstacle.dataset.counted = 'true';
                        obstaclesAvoided++;
                        obstaclesAvoidedEl = document.getElementById('obstaclesAvoided');
                        if (obstaclesAvoidedEl) {
                            obstaclesAvoidedEl.textContent = obstaclesAvoided;
                        }
                        console.log('‚úÖ COUNTED: Obstacle avoided! Count:', obstaclesAvoided, '/', targetObstacles, 
                                  '| ObstacleRight:', obstacleRight.toFixed(0), 
                                  'ReindeerLeft:', reindeerLeft.toFixed(0),
                                  'Diff:', (reindeerLeft - obstacleRight).toFixed(0));
                        
                        if (obstaclesAvoided >= targetObstacles) {
                            endGame(true);
                            return;
                        }
                    }
                }

                // Check collision when obstacle is in the reindeer's area AND hasn't been counted yet
                if (!isCounted) {
                    // Simplified collision zone check - check if obstacle overlaps with reindeer
                    const isInCollisionZone = obstacleRight >= reindeerLeft - 5 && obstacleLeft <= reindeerRight + 5;
                    
                    if (isInCollisionZone) {
                        // Check collision with full position data
                        if (checkCollision(obstacleLeft, obstacleRight, obstacleTop, obstacleBottom)) {
                            console.log('üí• COLLISION DETECTED!');
                            endGame(false);
                            return;
                        }
                    }
                }

                // Remove obstacle when off-screen to the left (with extra buffer)
                // IMPORTANT: Only remove if it's been counted OR if it's way off screen
                // Increased buffer to ensure obstacles stay visible longer
                if (obstacleRight < -obstacleWidth * 5) {
                    obstaclesToRemove.push(index);
                    obstacle.remove();
                }
            });

            // Remove obstacles from array (in reverse to maintain indices)
            obstaclesToRemove.reverse().forEach(index => {
                if (index >= 0 && index < obstacles.length) {
                    obstacles.splice(index, 1);
                }
            });
            
            // Debug: Log current state periodically (less frequent to avoid spam)
            if (gameRunning && obstacles.length > 0 && obstaclesAvoided < targetObstacles) {
                const uncounted = obstacles.filter(obs => obs.dataset.counted !== 'true').length;
                const counted = obstacles.filter(obs => obs.dataset.counted === 'true').length;
                // Only log every 60 frames (about once per second at 60fps)
                if (!window.frameCount) window.frameCount = 0;
                window.frameCount++;
                if (window.frameCount % 60 === 0) {
                    console.log('Game state - Avoided:', obstaclesAvoided, '/', targetObstacles, '| Obstacles on screen:', obstacles.length, '| Counted:', counted, '| Uncounted:', uncounted);
                }
            }
            
            // Log if no obstacles exist but game is running
            if (gameRunning && obstacles.length === 0 && obstaclesAvoided < targetObstacles) {
                if (!window.lastNoObstacleLog || Date.now() - window.lastNoObstacleLog > 2000) {
                    console.warn('‚ö†Ô∏è No obstacles on screen but game is running! Creating one...');
                    createObstacle();
                    window.lastNoObstacleLog = Date.now();
                }
            }

            // Continue game loop
            if (gameRunning) {
                animationFrame = requestAnimationFrame(updateObstacles);
            }
        }

        // Safety check function to prevent stuck states
        function checkGameState() {
            // Safety check: if game is running but no obstacles are being created, restart
            if (gameRunning && obstacles.length === 0 && obstaclesAvoided < targetObstacles) {
                console.warn('Game state check: No obstacles found, creating one...');
                createObstacle();
            }
            
            // Safety check: if score is stuck, try to recover
            if (gameRunning && obstaclesAvoided < targetObstacles) {
                // Check ALL obstacles on screen for missed counts
                obstacles.forEach(obs => {
                    if (obs.dataset.counted !== 'true') {
                        const obsLeft = parseFloat(obs.style.left) || 0;
                        const obsWidth = parseFloat(obs.dataset.width) || getObstacleWidth();
                        const obsRight = obsLeft + obsWidth;
                        const reindeerLeft = getReindeerLeft();
                        
                        // If obstacle has clearly passed reindeer, count it
                        if (obsRight < reindeerLeft - 5) {
                            obs.dataset.counted = 'true';
                            obstaclesAvoided++;
                            obstaclesAvoidedEl = document.getElementById('obstaclesAvoided');
                            if (obstaclesAvoidedEl) {
                                obstaclesAvoidedEl.textContent = obstaclesAvoided;
                            }
                            console.warn('üîÑ RECOVERY: Counted missed obstacle! New count:', obstaclesAvoided, '| Obstacle position:', obsRight.toFixed(0), '| Reindeer:', reindeerLeft.toFixed(0));
                            
                            if (obstaclesAvoided >= targetObstacles) {
                                endGame(true);
                            }
                        }
                    }
                });
                
                // If no obstacles and score is low, create more
                if (obstacles.length === 0 && obstaclesAvoided < targetObstacles) {
                    console.warn('‚ö†Ô∏è No obstacles found, creating one...');
                    createObstacle();
                }
            }
        }

        function startGame() {
            if (gameRunning) return;
            
            gameRunning = true;
            obstaclesAvoided = 0; // Reset counter
            obstacles = [];
            isJumping = false;
            
            // Update reindeer position for current screen size
            updateReindeerPosition();
            
            // Reset display
            if (obstaclesAvoidedEl) {
                obstaclesAvoidedEl.textContent = '0';
            }
            if (gameOver) gameOver.classList.remove('show');
            if (jumpButton) jumpButton.disabled = false;
            
            // Reset reindeer position
            if (reindeer) {
                reindeer.classList.remove('jumping');
            }
            
            // Clear any existing obstacles
            document.querySelectorAll('.obstacle').forEach(obs => obs.remove());
            
            // Reset game status
            const gameStatus = document.getElementById('gameStatus');
            if (gameStatus) {
                gameStatus.classList.remove('completed');
                gameStatus.innerHTML = '<div>Navigate through obstacles</div><div class="progress-indicator">Obstacles Avoided: <span id="obstaclesAvoided">0</span>/5</div>';
                // Re-get the element reference after updating HTML
                obstaclesAvoidedEl = document.getElementById('obstaclesAvoided');
                console.log('Game started. Counter element:', obstaclesAvoidedEl ? 'Found' : 'NOT FOUND');
            }
            
            // Create first obstacle after a short delay
            setTimeout(() => {
                if (gameRunning && gameArea) {
                    console.log('üéÆ Starting obstacle creation...');
                    console.log('Game area dimensions:', gameArea.offsetWidth + 'x' + gameArea.offsetHeight);
                    createObstacle();
                    // Create new obstacles at intervals with proper gaps
                    obstacleInterval = setInterval(() => {
                        if (gameRunning && obstacles.length < 3) {
                            createObstacle();
                        }
                    }, 2000); // Increased interval to 2000ms to ensure gaps between obstacles
                } else {
                    console.error('‚ùå Cannot start obstacle creation: gameRunning=', gameRunning, 'gameArea=', !!gameArea);
                }
            }, 500); // Reduced initial delay to 500ms for faster start

            // Start the game loop
            updateObstacles();
            
            // Periodic safety checks
            setInterval(() => {
                if (gameRunning) {
                    checkGameState();
                }
            }, 2000);
        }

        function endGame(success) {
            gameRunning = false;
            if (obstacleInterval) {
                clearInterval(obstacleInterval);
                obstacleInterval = null;
            }
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            if (jumpButton) jumpButton.disabled = true;

            if (success) {
                const gameStatus = document.getElementById('gameStatus');
                if (gameStatus) {
                    gameStatus.classList.add('completed');
                    gameStatus.innerHTML = '<div>üéâ Challenge Complete! All obstacles avoided!</div>';
                }
                const completeForm = document.getElementById('completeForm');
                if (completeForm) {
                    completeForm.style.display = 'inline-block';
                }
            } else {
                if (gameOver) gameOver.classList.add('show');
            }
        }

        function restartGame() {
            if (gameOver) gameOver.classList.remove('show');
            
            // Clear all obstacles
            obstacles.forEach(obs => {
                if (obs.parentNode) {
                    obs.remove();
                }
            });
            obstacles = [];
            obstaclesAvoided = 0;
            isJumping = false;
            
            // Update reindeer position for current screen size
            updateReindeerPosition();
            
            const gameStatus = document.getElementById('gameStatus');
            if (gameStatus) {
                gameStatus.classList.remove('completed');
                gameStatus.innerHTML = '<div>Navigate through obstacles</div><div class="progress-indicator">Obstacles Avoided: <span id="obstaclesAvoided">0</span>/5</div>';
            }
            obstaclesAvoidedEl = document.getElementById('obstaclesAvoided');
            
            // Reset reindeer
            if (reindeer) {
                reindeer.classList.remove('jumping');
            }
            
            startGame();
        }

        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') {
                e.preventDefault();
                jump();
            }
        });

        // Start game automatically after page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(startGame, 500);
            });
        } else {
            setTimeout(startGame, 500);
        }

        // Make functions available globally
        window.restartGame = restartGame;
        window.jump = jump;
    })();
    {% endif %}
</script>
{% endblock %}

